- <a href="https://play.picoctf.org/practice/challenge/78">b00tl3gRSA3</a>

![s00413306102025](https://a.okmd.dev/md/684731e7535a6.png)  
After running the command on the terminal, I was greeted with this:
```
nc jupiter.challenges.picoctf.org 3726
c: 16459726482853438836757522317076603838890757431682273248888681319597911456533269231686666816218212946045256985659794594258021026215140102112332367415052922595180340773386580432168534115690896467045947031062178875446409521921805913767911567996526082335652307297924654319352500978587970455499673703947689154212022882656705486926434435092811055114
n: 106777309886074633018297987082734487264243129075351103259726403090489420462414010237851456104681181411437916163510469349798830639680893438350005154428107879885001319930130334189520783656078190404021192589239204647365621866193970958040903478023448542921859115054588756533747481191354788410800955273751324413892560722069042577095602760227762807973
e: 65537
```

The hint stated that n will have more than just two prime numbers, so the first thing that I did is calculate to see how many prime factors are present for this number.

Therefore, instead of using an online decipherer, I wrote a python script that would perform this task for me:
```Python
import random
import math
from Crypto.Util.number import inverse, long_to_bytes

def rho(n):
    if n%2==0: return 2
    x=random.randrange(2,n-1)
    y=x
    c=random.randrange(1,n-1)
    d=1
    while d==1:
        x=(pow(x,2,n)+c)%n
        y=(pow(y,2,n)+c)%n
        y=(pow(y,2,n)+c)%n
        d=math.gcd(abs(x-y),n)
        if d==n: return rho(n)
    return d

def is_prime(n):
    if n<2: return False
    for a in [2,3,5,7,11,13,17,19,23,29]:
        if n==a: return True
        if n%a==0: return False
    d=n-1
    s=0
    while d%2==0:
        d//=2
        s+=1
    for a in [2,325,9375,28178,450775,9780504,1795265022]:
        if a%n==0: continue
        x=pow(a,d,n)
        if x==1 or x==n-1: continue
        for _ in range(s-1):
            x=pow(x,2,n)
            if x==n-1: break
        else: return False
    return True

def factor(n):
    if n==1: return []
    if is_prime(n): return [n]
    d=rho(n)
    return factor(d)+factor(n//d)

n=106777309886074633018297987082734487264243129075351103259726403090489420462414010237851456104681181411437916163510469349798830639680893438350005154428107879885001319930130334189520783656078190404021192589239204647365621866193970958040903478023448542921859115054588756533747481191354788410800955273751324413892560722069042577095602760227762807973
e=65537
c=16459726482853438836757522317076603838890757431682273248888681319597911456533269231686666816218212946045256985659794594258021026215140102112332367415052922595180340773386580432168534115690896467045947031062178875446409521921805913767911567996526082335652307297924654319352500978587970455499673703947689154212022882656705486926434435092811055114

pr=factor(n)
ph=1
for p in pr: ph*=(p-1)
d=inverse(e,ph)
m=pow(c,d,n)
print(long_to_bytes(m).decode())
```
Running this program directly gave me the answer. 

### Answer:
```
picoCTF{too_many_fact0rs_8606199}
```

### References and Links:
*NULL*